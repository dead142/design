#Инкапсуляция, наследование, полиморфизм.

## Инкапсуляция

**Инкапсуляция** — это свойств о системы, позволяющее объединить данные и методы, работающие с ними, в классе, и скрыть детали реализации от пользователя.

Предположим, у нас имеется некий класс ```Vehicle```, моделирующий устройство и поведение некой простейшей технической единицы, скажем, в компьютерной игре.

```php
Class Vehicle{
   // Запас “жизней” юнита
   Public $hits;
   // Метод, отвечающий за получение юнитом повреждений в игре... 
   public function getDamage($damage){
            $this->hits -= $damage;
          }
}
```

В этом простом примере в классе, моделирующем объект, мы описали некие данные - запас “жизней” игрового юнита - 
```$hits```, а также запрограммировали реализацию обработки этих данных - 
метод, получения юнитом повреждений - ```getDamage()```. Таким образом, говорят,
 что данные и механизмы их обработки/модификации инкапсулированы в классе ```Vehicle```.

## Наследование

**Наследование** — это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым, родительским или суперклассом. Новый класс — потомком, наследником, дочерним или производным классом.

Продолжим наш пример с описанием объектов некоторой компьютерной игры.
 Предположим, у нас есть также класс объектов ```Tank```, который логически также принадлежит к технике.
  Вместо того, чтобы описывать Tank как полностью отдельный и самостоятельный класс с дублированием всех тех 
  же данных и методов, что есть у любой техники (Vehicle) в игре, можно описать класс Tank, 
  как дочерний класс от класса Vehicle, дополнив его только свойствами и методами, которые свойственны 
  именно классу ```Tank```:
  
```php
...

class Tank extends Vehicle {

// Броня
public $armor;

// Окопаться 
public function trench(){
// Реализация...
}
}
```

Таким образом, класс ```Tank``` полностью наследует разрешенный* набор полей и методов родительского 
класса ```Vehicle``` вместе с реализацией, без необходимости определять их в самом классе ```Tank```, 
т.к. их реализация вполне подходит и для данного класса.
 Но на практике часто возникает потребность изменить поведение родительского класса в классах - потомках,
  и тут в игру вступает вид следующего принципа - полиморфизма наследования.

##Полиморфизм

**Полиморфизм** (одно из определений) - (многоформенность) является следствием идеи наследования. В общих словах, полиморфность класса — это свойство базового класса использовать функции производных классов, даже если на момент определения еще неизвестно, какой именно класс будет включать его в качестве базового и, тем самым, становиться от него производным.

Рассмотрим следующий вид полиморфизма:

Предположим, каждый юнит в нашей игре также имеет название, которое хранится в поле ```$name```;

```php
classVehicle{
   // Название
   public $name;

   ...

   // Метод, возвращающий строку с названием юнита. 
   public function getIntroductionPhrase(){
return “I’m abstract unit ” . $this->name;
   }

          // Представить юнить:
          public function introduce(){
echo $this->getIntroductionPhrase();
          }
}
```

Базовый класс дополним двумя методами. Один из которых возвращает строку, представляющую данный юнит. Второй - просто выводит эту строку в код страницы.

Далее переопределим метод ```getIntroductionPhrase()``` в классе ```Tank```, который наследует данный класс.

```php
class Tank extends Vehicle {

          ...

          // Метод, возвращающий строку с названием юнита. 
   public function getIntroductionPhrase(){
             return “I’m Tank ” . $this->name . “. Awaiting for your orders.”;
          }

}
```

Таким образом, если мы создадим экземпляр класса ```Tank``` и вызовем
 унаследованный метод ```introduce()```, то в нём в итоге будет вызван не унаследованный метод
  ```getIntroductionPhrase()```, а тот, который определён именно в классе ```Tank```:

```php
...
$tank1 = new Tank();
$tank1->name = “T-82”;
$tank1->introduce();
...
```

Вывод:

```I’m Tank T-82. Awaiting for your orders.```

