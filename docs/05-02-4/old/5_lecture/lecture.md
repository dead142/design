# Конструктор и деструктор.

## Конструктор
```void __construct ([ mixed $args = "" [, $... ]] )```

PHP позволяет объявлять методы-конструкторы. Они автоматически исполняются при создании класса и служат для задания начальных значений свойствам класса. Классы, в которых объявлен метод-конструктор, будут вызывать этот метод при каждом создании нового объекта, так что это может оказаться полезным, например, для инициализации какого-либо состояния объекта перед его использованием.

>**Замечание:** Конструкторы в классах-родителях не вызываются автоматически, если класс-потомок 
>определяет собственный конструктор. Чтобы вызвать конструктор, объявленный в
> родительском классе, следует обратиться к методу ```parent::__construct()```
>внутри конструктора класса-потомка. Если в классе-потомке не определе
> конструктор, то он может наследоваться от родительского класса как обычный метод 
>(если он не определен как приватный).
>
### Пример #1 Использование унифицированных конструкторов

```php
<?php
class BaseClass {
   function __construct() {
       print "Конструктор класса BaseClass\n";
   }
}

class SubClass extends BaseClass {
   function __construct() {
       parent::__construct();
       print "Конструктор класса SubClass\n";
   }
}

class OtherSubClass extends BaseClass {
    // inherits BaseClass's constructor
}

// In BaseClass constructor
$obj = new BaseClass();

// In BaseClass constructor
// In SubClass constructor
$obj = new SubClass();

// In BaseClass constructor
$obj = new OtherSubClass();
?>
```

В целях обратной совместимости, если PHP не может обнаружить объявленный метод ```__construct()``` и этот метод 
не наследуется от родительских классов, то вызов конструктора произойдет по устаревшей схеме, через обращение к
 методу, имя которого соответствует имени класса. Может возникнуть только одна проблема совместимости
  старого кода, если в нём присутствуют классы с методами ```__construct()```, использующиеся для других целей.

В отличие от других методов, PHP не будет генерировать ошибку уровня ```E_STRICT```, если ```__construct()```
 будет перекрыт методом с другими параметрами, отличными от тех, которые находятся в родительском ```__construct()```.

Начиная с версии PHP 5.3.3, методы с именами, совпадающими с последним элементом имени класса, находящимся в пространстве имен, больше не будут считаться конструкторами. Это изменение не влияет на классы, не находящиеся в пространстве имен.

### Пример #2 Конструкторы в классах, находящихся в пространстве имен
```php
<?php
namespace Foo;
class Bar {
    public function Bar() {
        // конструктор в версиях PHP 5.3.0-5.3.2
        // обычный метод, начиная с версии PHP 5.3.3
    }
}
?>
```
## Деструкторы
```void __destruct ( void )```
PHP предоставляет концепцию деструкторов, сходную с теми, что применяются в других ОО языках, таких, как C++. Деструктор будет вызван при освобождении всех ссылок на определенный объект или при завершении скрипта (порядок выполнения деструкторов не гарантируется). 

### Пример #3 Пример использования деструктора

```php
<?php
class MyDestructableClass {
   function __construct() {
       print "Конструктор\n";
       $this->name = "MyDestructableClass";
   }

   function __destruct() {
       print "Уничтожается " . $this->name . "\n";
   }
}

$obj = new MyDestructableClass();
?>
```

Как и в случае с конструкторами, деструкторы, объявленные в родительском классе, не будут
 вызваны автоматически. Для вызова деструктора, объявленном в классе-родителе, следует
  обратиться к методу ```parent::__destruct()``` в теле деструктора-потомка. Также класс-потомок может унаследовать деструктор из родительского класса, если он не определен в нем.

Деструктор будет вызван даже в том случае, если скрипт был остановлен с помощью функции ```exit()```. 
Вызов ```exit()``` в деструкторе предотвратит запуск всех последующих функций завершения.

>**Замечание:**
>Деструкторы, вызываемые при завершении скрипта, вызываются после отправки HTTP-заголовков. Рабочая директория во время фазы завершения скрипта может отличаться в некоторых SAPI (например, в Apache).

>**Замечание:**
>Попытка бросить исключение в деструкторе (вызванного во время завершения скрипта) влечет за собой фатальную ошибку.

